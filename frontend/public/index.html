<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KataGo Web 对局 MVP</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; }
    header { padding: 12px 16px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
    main { display: grid; grid-template-columns: 1fr 280px; gap: 16px; padding: 16px; }
    #board { width: 640px; height: 640px; background: #f3c98b; border: 1px solid #ccc; position: relative; }
    .panel { border: 1px solid #eee; padding: 12px; border-radius: 8px; }
    .row { margin-bottom: 8px; }
    button { padding: 6px 12px; }
    #log { height: 160px; overflow: auto; background: #fafafa; border: 1px solid #eee; padding: 8px; }
  </style>
</head>
<body>
  <header>
    <div>KataGo Web 对局 MVP</div>
    <div id="status">状态: 未连接</div>
  </header>
  <main>
    <div>
      <canvas id="board" width="640" height="640"></canvas>
      <div class="panel" style="margin-top:12px;">
        <div class="row"><strong>日志</strong></div>
        <pre id="log"></pre>
      </div>
    </div>
    <div class="panel">
      <div class="row"><strong>对局控制</strong></div>
      <div class="row">
        难度：
        <select id="level">
          <option value="1">1★</option>
          <option value="2">2★</option>
          <option value="3" selected>3★</option>
          <option value="4">4★</option>
          <option value="5">5★</option>
        </select>
      </div>
      <div class="row">
        执方：
        <select id="playerColor">
          <option value="black" selected>我执黑（先手）</option>
          <option value="white">我执白（后手）</option>
        </select>
      </div>
      <div class="row">
        <button id="newGame">新开对局</button>
        <button id="resign" disabled>认输</button>
      </div>
      <div class="row" style="font-size:12px;color:#666">并发上限：3 局</div>
    </div>
  </main>
  <script>
    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const board = document.getElementById('board');
    const ctx = board.getContext('2d');

    let gameId = null;
    let heartbeatTimer = null;
    let stones = []; // {x:0..18, y:0..18, color:'black'|'white'}
    let playerColor = 'black';
    let isPlayingRequest = false;

    function log(msg){
      const t = new Date().toLocaleTimeString();
      logEl.textContent += `[${t}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function drawBoard(){
      ctx.clearRect(0,0,640,640);
      ctx.fillStyle = '#f3c98b';
      ctx.fillRect(0,0,640,640);
      ctx.strokeStyle = '#444';
      for(let i=0;i<19;i++){
        const x = 20 + i * 32; // 19线*间距32≈576，留些边距
        ctx.beginPath(); ctx.moveTo(32, x); ctx.lineTo(608, x); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x, 32); ctx.lineTo(x, 608); ctx.stroke();
      }
      drawStarPoints();
      drawStones();
    }

    drawBoard();

    function drawStarPoints(){
      // 标准 19 路棋盘九个星位
      const pts = [3,9,15];
      ctx.fillStyle = '#333';
      for(const i of pts){
        for(const j of pts){
          const cx = 32 + i*32;
          const cy = 32 + j*32;
          ctx.beginPath();
          ctx.arc(cx, cy, 3, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    function drawStones(){
      for(const s of stones){
        const cx = 32 + s.x*32;
        const cy = 32 + s.y*32;
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI*2);
        const grad = ctx.createRadialGradient(cx-6, cy-6, 2, cx, cy, 16);
        if(s.color === 'black'){
          grad.addColorStop(0, '#666');
          grad.addColorStop(1, '#111');
        }else{
          grad.addColorStop(0, '#fff');
          grad.addColorStop(1, '#ddd');
        }
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = '#00000022';
        ctx.stroke();
      }
    }

    function updateStatus(){
      fetch('/api/engine/status')
        .then(r=>r.json())
        .then(j=>{ statusEl.textContent = `状态: 在线, 活动局 ${j.activeGames}/3`; })
        .catch(()=>{ statusEl.textContent = '状态: 不可用'; });
    }

    function moveToCoord(mv){
      // 将 'Q16' → {x:colIndex(0..18), y:rowIndex(0..18)}，(0,0) 为左上角
      if(!mv || mv === 'pass' || mv === 'resign') return null;
      const letters = 'ABCDEFGHJKLMNOPQRST';
      const colChar = mv[0].toUpperCase();
      const col = letters.indexOf(colChar);
      const rowNum = parseInt(mv.slice(1), 10);
      if(col < 0 || isNaN(rowNum)) return null;
      const y = 19 - rowNum; // 屏幕 y 向下
      const x = col;
      if(x<0||x>18||y<0||y>18) return null;
      return {x, y};
    }

    function hasStone(x, y){
      return stones.some(s => s.x === x && s.y === y);
    }

    function stoneColorAt(x, y){
      const s = stones.find(s => s.x === x && s.y === y);
      return s ? s.color : null;
    }

    function neighbors(x, y){
      const out = [];
      if(x>0) out.push({x:x-1,y});
      if(x<18) out.push({x:x+1,y});
      if(y>0) out.push({x,y:y-1});
      if(y<18) out.push({x,y:y+1});
      return out;
    }

    function groupAndLiberties(startX, startY){
      const color = stoneColorAt(startX,startY);
      if(!color) return {group:[], liberties:new Set()};
      const key = (p)=>p.x+','+p.y;
      const seen = new Set([key({x:startX,y:startY})]);
      const group = [{x:startX,y:startY}];
      const liberties = new Set();
      const q = [{x:startX,y:startY}];
      while(q.length){
        const p = q.pop();
        for(const nb of neighbors(p.x,p.y)){
          const c = stoneColorAt(nb.x, nb.y);
          if(!c){ liberties.add(key(nb)); continue; }
          if(c === color){
            const k = key(nb);
            if(!seen.has(k)){
              seen.add(k);
              group.push(nb);
              q.push(nb);
            }
          }
        }
      }
      return {group, liberties};
    }

    function removeGroup(group){
      const set = new Set(group.map(p=>p.x+","+p.y));
      stones = stones.filter(s => !set.has(s.x+","+s.y));
    }

    function applyMoveLocal(color, x, y){
      // 放置
      stones.push({x,y,color});
      // 先检查并提掉对方相邻气尽的块
      const opp = (color === 'black') ? 'white' : 'black';
      let totalCaptures = 0;
      for(const nb of neighbors(x,y)){
        if(stoneColorAt(nb.x, nb.y) === opp){
          const {group, liberties} = groupAndLiberties(nb.x, nb.y);
          if(liberties.size === 0){
            totalCaptures += group.length;
            removeGroup(group);
          }
        }
      }
      // 再检查己方这块是否还有气（防自杀，除非刚刚提子产生气）
      const selfInfo = groupAndLiberties(x,y);
      if(selfInfo.liberties.size === 0){
        // 自杀，回滚
        stones = stones.filter(s => !(s.x===x && s.y===y && s.color===color));
        return {ok:false, captures:0};
      }
      return {ok:true, captures:totalCaptures};
    }

    async function newGame(){
      const level = document.getElementById('level').value;
      playerColor = document.getElementById('playerColor').value;
      const body = { boardSize: 19, rules: 'japanese', komi: 6.5, handicap: 0, engineLevel: Number(level), playerColor };
      const res = await fetch('/api/game/new', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(body) });
      if(res.status === 429){
        const j = await res.json();
        alert(`过载：${j.message}`);
        return;
      }
      if(!res.ok){ log('新开对局失败'); return; }
      const j = await res.json();
      gameId = j.gameId;
      log(`新开对局: ${gameId}`);
      stones = [];
      if(j.engineMove){
        log(`AI 首手: ${j.engineMove}`);
        const coord = moveToCoord(j.engineMove);
        const aiColor = (playerColor === 'white') ? 'black' : 'white';
        if(coord){
          applyMoveLocal(aiColor, coord.x, coord.y);
        }
      }
      document.getElementById('resign').disabled = false;
      startHeartbeat();
      updateStatus();
      drawBoard();
    }

    function startHeartbeat(){
      stopHeartbeat();
      heartbeatTimer = setInterval(async ()=>{
        if(!gameId) return;
        await fetch('/api/game/heartbeat', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ gameId }) });
      }, 15000);
    }
    function stopHeartbeat(){ if(heartbeatTimer){ clearInterval(heartbeatTimer); heartbeatTimer=null; } }

    function coordToMove(x,y){
      // 简化：将点击转换为最近的交叉点，再转 SGF 坐标（A1 起）
      const gx = Math.round((x-32)/32);
      const gy = Math.round((y-32)/32);
      if(gx<0||gx>18||gy<0||gy>18) return null;
      const letters = 'ABCDEFGHJKLMNOPQRST';
      const col = letters[gx];
      const row = 19-gy;
      return col + row;
    }

    board.addEventListener('click', async (e)=>{
      if(!gameId){ alert('请先新开对局'); return; }
      if(isPlayingRequest){ return; } // 并发点击保护
      const rect = board.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const mv = coordToMove(x,y);
      if(!mv) return;

      const coord = moveToCoord(mv);
      if(!coord) return;
      if(hasStone(coord.x, coord.y)){
        log(`该点已有棋子: ${mv}`);
        return;
      }

      log(`你落子: ${mv}`);
      // 本地规则：先行检测自杀禁手和提子效果（乐观）
      const applied = applyMoveLocal(playerColor, coord.x, coord.y);
      if(!applied.ok){
        log('非法落子（自杀禁手），已阻止');
        return;
      }
      if(applied.captures>0){ log(`提子: ${applied.captures}`); }
      drawBoard();

      isPlayingRequest = true;
      try{
        const res = await fetch('/api/game/play', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ gameId, playerMove: mv }) });
        if(res.status === 410){
          alert('对局已过期');
          // 回滚你刚才那手
          stones = stones.filter(s => !(s.x===coord.x && s.y===coord.y && s.color===playerColor));
          drawBoard();
          return;
        }
        if(!res.ok){
          log('落子失败');
          // 回滚
          stones = stones.filter(s => !(s.x===coord.x && s.y===coord.y && s.color===playerColor));
          drawBoard();
          return;
        }
        const j = await res.json();
        log(`AI 应手: ${j.engineMove}`);
        const ai = moveToCoord(j.engineMove);
        const aiColor = (playerColor === 'black') ? 'white' : 'black';
        if(ai){
          const result = applyMoveLocal(aiColor, ai.x, ai.y);
          if(result.captures>0){ log(`AI 提子: ${result.captures}`); }
        }
        drawBoard();
        updateStatus();
      }catch(err){
        log('网络错误：' + err);
        // 回滚：移除你刚才的落子（以及由于它产生的提子无法简单恢复，这里直接重置到“移除你的子”的近似状态）
        stones = stones.filter(s => !(s.x===coord.x && s.y===coord.y && s.color===playerColor));
        drawBoard();
      }finally{
        isPlayingRequest = false;
      }
    });

    document.getElementById('newGame').onclick = newGame;
    document.getElementById('resign').onclick = async ()=>{
      if(!gameId) return;
      await fetch('/api/game/close', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ gameId }) });
      stopHeartbeat();
      log('你认输，已关闭对局');
      gameId = null;
      document.getElementById('resign').disabled = true;
      stones = [];
      updateStatus();
      drawBoard();
    };

    updateStatus();
  </script>
</body>
</html>
