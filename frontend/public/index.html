<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KataGo Web 对局 MVP</title>
  <style>
    :root { --primary:#1677ff; --border:#eee; --text:#333; --panel-bg:#fff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; color: var(--text); }
    header { padding: 12px 16px; border-bottom: 1px solid #eee; display: flex; justify-content: center; align-items: center; font-weight:600; }
    main { display: flex; flex-direction: column; align-items: center; gap: 16px; padding: 16px; }
    #board { width: 640px; height: 640px; background: #f3c98b; border: 1px solid #ccc; position: relative; }
    #boardWrap { }
    #controlsPanel { position: static; display: grid; grid-template-columns: 1fr 1fr 1fr; justify-content: center; column-gap: 16px; row-gap: 10px; width: 640px; max-width: 90vw; background: var(--panel-bg); box-shadow: 0 1px 3px #0000000f; border: 1px solid var(--border); border-radius: 10px; padding-top: 8px; padding-bottom: 8px; }
    #controlsPanel .row { display: flex; align-items: center; gap: 8px; }
    #controlsPanel .row.center { justify-content: center; }
    #controlsPanel .label { min-width: 48px; text-align: right; color: #333; }
    #controlsPanel .span-3 { grid-column: 1 / -1; }
    /* 难度选择框 */
    select#levelSelect { padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; background: #fff; }
    /* 执方开关 */
    .toggle { display: inline-flex; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; }
    .toggle button { padding: 8px 12px; border: 0; background: #fff; cursor: pointer; }
    .toggle button.active { background: var(--primary); color: #fff; }
    /* 头像 */
    .avatar { width: 40px; height: 40px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; background:#f0f2f5; border:1px solid var(--border); font-weight: 600; color:#555; box-shadow: 0 1px 2px #0000000a; transition: transform .18s ease, box-shadow .18s ease; }
    .avatar.you { background:#e6f4ff; color:#1677ff; }
    .avatar.ai { background:#fff7e6; color:#fa8c16; }
    .avatar.turn { transform: scale(1.22); box-shadow: 0 0 0 3px rgba(22,119,255,0.18), 0 2px 8px rgba(0,0,0,0.12); }
    .avatar-box { display:flex; flex-direction:column; align-items:center; gap:4px; font-size:12px; color:#666; }
    .meta { display:flex; align-items:center; gap:6px; }
    .color-dot { width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid #999; }
    .color-dot.black { background:#111; border-color:#000; }
    .color-dot.white { background:#fff; border-color:#999; }
    .btn-group { display:inline-flex; gap:10px; }
    /* 按钮 */
    .btn { padding: 8px 14px; border-radius: 8px; border: 1px solid var(--border); background: #fff; cursor: pointer; transition: all .15s ease; }
    .btn:hover { box-shadow: 0 2px 6px #00000014; }
    .btn-primary { background: var(--primary); color:#fff; border-color: var(--primary); }
    .btn-primary:hover { filter: brightness(1.05); }
    .btn[disabled] { opacity: .6; cursor: not-allowed; }
    .btn-primary[disabled] { background:#c9c9c9; border-color:#c9c9c9; color:#fff; }
    /* 日志开关 Switch */
    .switch { display:inline-flex; align-items:center; gap:8px; cursor:pointer; user-select:none; }
    .switch input { position:absolute; opacity:0; width:0; height:0; }
    .switch .slider { width:40px; height:22px; background:#ccc; border-radius:999px; position:relative; transition:background .15s ease; }
    .switch .slider::before { content:""; position:absolute; width:18px; height:18px; background:#fff; border-radius:50%; left:2px; top:2px; box-shadow:0 1px 3px #00000033; transition:transform .15s ease; }
    .switch input:checked + .slider { background: var(--primary); }
    .switch input:checked + .slider::before { transform: translateX(18px); }
    #logsPanel { width: 640px; max-width: 90vw; }
    .panel { border: 1px solid #eee; padding: 12px; border-radius: 8px; background: var(--panel-bg); }
    .row { margin-bottom: 8px; }
    button { padding: 6px 12px; }
    #log { height: 180px; overflow: auto; background: #fafafa; border: 1px solid #eee; padding: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; resize: vertical; }
    .caps { font-size: 13px; color:#333; }
    
  </style>
</head>
<body>
  <!-- 居中提示浮层 -->
  <style>
    #toast { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%) scale(0.98); background: rgba(0,0,0,0.85); color:#fff; padding: 10px 16px; border-radius: 10px; box-shadow: 0 6px 20px #00000033; opacity: 0; pointer-events: none; transition: opacity .18s ease, transform .18s ease; z-index: 9999; font-size:14px; }
    #toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  </style>
  <div id="toast" role="status" aria-live="polite" aria-atomic="true"></div>
  <header>
    <div>KataGo Web</div>
  </header>
  <main>
    <div class="panel" id="controlsPanel">
      <!-- 第一行：执子选择 | 难度 | 调试模式 -->
      <div class="row" style="grid-column:1; justify-content:flex-start;">
        <span class="label">执子：</span>
        <div class="toggle" id="colorToggle">
          <button type="button" data-color="black" class="active">执黑</button>
          <button type="button" data-color="white">执白</button>
        </div>
      </div>
      <div class="row" style="grid-column:2; justify-content:center;">
        <span class="label">难度：</span>
        <select id="levelSelect">
          <option value="1">★ 一星</option>
          <option value="2" selected>★★ 二星</option>
          <option value="3">★★★ 三星</option>
          <option value="4">★★★★ 四星</option>
          <option value="5">★★★★★ 五星</option>
        </select>
      </div>
      <div class="row" style="grid-column:3; justify-content:flex-end;">
        <label class="switch">
          <input type="checkbox" id="debugSwitch">
          <span class="slider"></span>
          <span>调试模式</span>
        </label>
      </div>

      <!-- 第二行：头像 | 按钮组 | 头像 -->
      <div class="row center" style="grid-column:1;">
        <div class="avatar-box">
          <div class="avatar you">我</div>
          <div class="meta"><span class="color-dot" id="meColor"></span> 吃掉: <span id="capMe">0</span></div>
        </div>
      </div>
      <div class="row center" style="grid-column:2;">
        <div class="btn-group">
          <button id="startBtn" class="btn btn-primary">开始</button>
          <button id="resign" class="btn" disabled>认输</button>
        </div>
      </div>
      <div class="row center" style="grid-column:3;">
        <div class="avatar-box">
          <div class="avatar ai">AI</div>
          <div class="meta"><span class="color-dot" id="aiColor"></span> 吃掉: <span id="capAI">0</span></div>
        </div>
      </div>

      
      
    </div>
    <div id="boardWrap">
      <canvas id="board" width="640" height="640"></canvas>
    </div>
    <div class="panel" id="logsPanel" style="display:none;">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <strong>日志</strong>
        <button id="clearLogsBtn" class="btn" style="padding:4px 8px; font-size:12px;">清空</button>
      </div>
      <pre id="log"></pre>
    </div>
  </main>
  <script>
    const logEl = document.getElementById('log');
    const statusEl = null; // header no longer shows status
    const board = document.getElementById('board');
    const ctx = board.getContext('2d');
    const capMeEl = document.getElementById('capMe');
    const capAIEl = document.getElementById('capAI');
    const logsPanel = document.getElementById('logsPanel');
    const colorToggle = document.getElementById('colorToggle');
    const levelSelect = document.getElementById('levelSelect');
    const startBtn = document.getElementById('startBtn');
    const debugSwitch = document.getElementById('debugSwitch');
    const resignBtn = document.getElementById('resign');
    const avatarYouEl = document.querySelector('.avatar.you');
    const avatarAiEl = document.querySelector('.avatar.ai');
    const colorButtons = colorToggle ? Array.from(colorToggle.querySelectorAll('button')) : [];
    // 日志显示改由调试模式开关控制

    const LOGS_KEY = 'katago_logs_v1';
    const LOGS_MAX = 500;
    function loadLogsMap(){
      try{ return JSON.parse(localStorage.getItem(LOGS_KEY) || '{}'); }catch(_){ return {}; }
    }
    function saveLogsMap(map){
      try{ localStorage.setItem(LOGS_KEY, JSON.stringify(map)); }catch(_){}
    }
    function currentLogKey(){ return gameId || null; }
    function renderLogs(){
      const map = loadLogsMap();
      const key = currentLogKey();
      const arr = key && Array.isArray(map[key]) ? map[key] : [];
      logEl.textContent = arr.join('\n') + (arr.length ? '\n' : '');
      logEl.scrollTop = logEl.scrollHeight;
    }
    function clearLogsForKey(key){
      const map = loadLogsMap();
      if(key){ map[key] = []; saveLogsMap(map); }
      renderLogs();
    }

    let gameId = null;
    let heartbeatTimer = null;
    let stones = []; // {x:0..18, y:0..18, color:'black'|'white'}
    let playerColor = 'black';
    let isStartingGame = false;
    // 最近一步高亮（人类/AI）与 AI 脉冲动画
    let lastHumanMove = null; // {x,y}
    let lastAiMove = null;    // {x,y}
    let aiPulseStartMs = 0;   // 动画起始时间
    let rafId = null;
    function getSelectedLevel(){
      return levelSelect ? Number(levelSelect.value) : 2;
    }
    colorToggle.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-color]');
      if(!btn) return;
      playerColor = btn.getAttribute('data-color');
      colorToggle.querySelectorAll('button').forEach(b=>b.classList.toggle('active', b===btn));
    });
    let isPlayingRequest = false;
    let caps = { black: 0, white: 0 };

    // 轮到谁下：高亮对应头像
    function setTurn(who){
      // who: 'you' | 'ai' | null
      if(avatarYouEl){ avatarYouEl.classList.toggle('turn', who === 'you'); }
      if(avatarAiEl){ avatarAiEl.classList.toggle('turn', who === 'ai'); }
    }

    // 开局后禁用“执子/难度”选择，结束后恢复
    function setPreGameControlsDisabled(disabled){
      if(levelSelect){ levelSelect.disabled = disabled; }
      if(colorButtons && colorButtons.length){ colorButtons.forEach(b=> b.disabled = disabled); }
    }

    function updateCaps(){
      // 我执黑则我=black；我执白则我=white
      const me = (playerColor === 'black') ? 'black' : 'white';
      const ai = (playerColor === 'black') ? 'white' : 'black';
      capMeEl.textContent = caps[me];
      capAIEl.textContent = caps[ai];
      const meDot = document.getElementById('meColor');
      const aiDot = document.getElementById('aiColor');
      if(meDot && aiDot){
        meDot.classList.toggle('black', me === 'black');
        meDot.classList.toggle('white', me === 'white');
        aiDot.classList.toggle('black', ai === 'black');
        aiDot.classList.toggle('white', ai === 'white');
      }
    }

    function log(msg){
      const t = new Date().toLocaleTimeString();
      const line = `[${t}] ${msg}`;
      const map = loadLogsMap();
      const key = currentLogKey();
      const list = Array.isArray(map[key]) ? map[key] : [];
      list.push(line);
      if(list.length > LOGS_MAX){ list.splice(0, list.length - LOGS_MAX); }
      map[key] = list;
      saveLogsMap(map);
      renderLogs();
    }

    function drawBoard(){
      ctx.clearRect(0,0,640,640);
      ctx.fillStyle = '#f3c98b';
      ctx.fillRect(0,0,640,640);
      // 固定网格线宽，避免被上一次标记环(lineWidth=2/3)影响
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      for(let i=0;i<19;i++){
        const p = 32 + i * 32; // 19线*间距32≈576，边距各32
        ctx.beginPath(); ctx.moveTo(32, p); ctx.lineTo(608, p); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p, 32); ctx.lineTo(p, 608); ctx.stroke();
      }
      drawStarPoints();
      drawStones();
      drawMoveMarkers();
    }

    drawBoard();

    function drawStarPoints(){
      const pts = [3,9,15];
      ctx.fillStyle = '#333';
      for(const i of pts){
        for(const j of pts){
          const cx = 32 + i*32;
          const cy = 32 + j*32;
          ctx.beginPath();
          ctx.arc(cx, cy, 3, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    function drawStones(){
      for(const s of stones){
        const cx = 32 + s.x*32;
        const cy = 32 + s.y*32;
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI*2);
        const grad = ctx.createRadialGradient(cx-6, cy-6, 2, cx, cy, 16);
        if(s.color === 'black'){
          grad.addColorStop(0, '#666');
          grad.addColorStop(1, '#111');
        }else{
          grad.addColorStop(0, '#fff');
          grad.addColorStop(1, '#ddd');
        }
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = '#00000022';
        ctx.stroke();
      }
    }

    function drawMoveMarkers(){
      // 人类最近一步：细灰圈
      if(lastHumanMove){
        const cx = 32 + lastHumanMove.x*32;
        const cy = 32 + lastHumanMove.y*32;
        ctx.beginPath();
        ctx.arc(cx, cy, 17, 0, Math.PI*2);
        ctx.strokeStyle = '#8c8c8c90';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      // AI 最近一步：脉冲红圈动画
      if(lastAiMove){
        const cx = 32 + lastAiMove.x*32;
        const cy = 32 + lastAiMove.y*32;
        const elapsed = Math.max(0, performance.now() - aiPulseStartMs);
        const dur = 1200; // ms
        const t = Math.min(elapsed / dur, 1);
        const radius = 16 + 6 * (1 - t);
        const alpha = 0.9 * (1 - t);
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 77, 79, ${alpha.toFixed(3)})`;
        ctx.lineWidth = 3;
        ctx.stroke();
        if(t < 1 && rafId === null){ rafId = requestAnimationFrame(animLoop); }
      }
    }

    function animLoop(){
      rafId = null;
      drawBoard();
      if(performance.now() - aiPulseStartMs < 1200){ rafId = requestAnimationFrame(animLoop); }
    }

    function triggerAiPulse(){
      aiPulseStartMs = performance.now();
      if(rafId === null){ rafId = requestAnimationFrame(animLoop); }
    }

    // engine status UI/functionality removed

    function moveToCoord(mv){
      if(!mv || mv === 'pass' || mv === 'resign') return null;
      const letters = 'ABCDEFGHJKLMNOPQRST';
      const colChar = mv[0].toUpperCase();
      const col = letters.indexOf(colChar);
      const rowNum = parseInt(mv.slice(1), 10);
      if(col < 0 || isNaN(rowNum)) return null;
      const y = 19 - rowNum;
      const x = col;
      if(x<0||x>18||y<0||y>18) return null;
      return {x, y};
    }

    function hasStone(x, y){
      return stones.some(s => s.x === x && s.y === y);
    }

    function stoneColorAt(x, y){
      const s = stones.find(s => s.x === x && s.y === y);
      return s ? s.color : null;
    }

    function neighbors(x, y){
      const out = [];
      if(x>0) out.push({x:x-1,y});
      if(x<18) out.push({x:x+1,y});
      if(y>0) out.push({x,y:y-1});
      if(y<18) out.push({x,y:y+1});
      return out;
    }

    function groupAndLiberties(startX, startY){
      const color = stoneColorAt(startX,startY);
      if(!color) return {group:[], liberties:new Set()};
      const key = (p)=>p.x+','+p.y;
      const seen = new Set([key({x:startX,y:startY})]);
      const group = [{x:startX,y:startY}];
      const liberties = new Set();
      const q = [{x:startX,y:startY}];
      while(q.length){
        const p = q.pop();
        for(const nb of neighbors(p.x,p.y)){
          const c = stoneColorAt(nb.x, nb.y);
          if(!c){ liberties.add(key(nb)); continue; }
          if(c === color){
            const k = key(nb);
            if(!seen.has(k)){
              seen.add(k);
              group.push(nb);
              q.push(nb);
            }
          }
        }
      }
      return {group, liberties};
    }

    function removeGroup(group){
      const set = new Set(group.map(p=>p.x+","+p.y));
      stones = stones.filter(s => !set.has(s.x+","+s.y));
    }

    function applyMoveLocal(color, x, y){
      stones.push({x,y,color});
      const opp = (color === 'black') ? 'white' : 'black';
      let totalCaptures = 0;
      for(const nb of neighbors(x,y)){
        if(stoneColorAt(nb.x, nb.y) === opp){
          const {group, liberties} = groupAndLiberties(nb.x, nb.y);
          if(liberties.size === 0){
            totalCaptures += group.length;
            removeGroup(group);
          }
        }
      }
      const selfInfo = groupAndLiberties(x,y);
      if(selfInfo.liberties.size === 0){
        stones = stones.filter(s => !(s.x===x && s.y===y && s.color===color));
        return {ok:false, captures:0};
      }
      return {ok:true, captures:totalCaptures};
    }

    async function newGame(){
      try{
        isStartingGame = true;
        const level = getSelectedLevel();
        const body = { boardSize: 19, rules: 'chinese', komi: 6.5, engineLevel: Number(level), playerColor };
        // 开局前先提示将由谁先手
        setTurn(playerColor === 'black' ? 'you' : 'ai');
        // 一旦发起开局，禁用执子和难度
        setPreGameControlsDisabled(true);
        const res = await fetch('/api/game/new', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(body) });
        if(res.status === 429){
          const j = await res.json();
          showToast(`过载：${j.message}`);
          if(startBtn) startBtn.disabled = false;
          setPreGameControlsDisabled(false);
          return;
        }
        if(!res.ok){
          log(`新开对局失败（${res.status}）`);
          showToast(`新开对局失败（${res.status}）`);
          if(startBtn) startBtn.disabled = false;
          setPreGameControlsDisabled(false);
          return;
        }
        const j = await res.json();
      gameId = j.gameId;
      renderLogs(); // 切换至本局日志（初始为空）
      log(`新开对局: ${gameId}`);
      stones = [];
      caps = {black:0, white:0};
      updateCaps();
      if(j.engineMove){
        const mvStr = String(j.engineMove || '').trim();
        log(`AI 首手: ${mvStr}`);
        const coord = moveToCoord(mvStr);
        const aiColor = (playerColor === 'white') ? 'black' : 'white';
        if(coord){
          const r = applyMoveLocal(aiColor, coord.x, coord.y);
          if(r.captures>0){ caps[aiColor] += r.captures; updateCaps(); }
          lastAiMove = { x: coord.x, y: coord.y };
          triggerAiPulse();
        }
      }
      if(resignBtn){ resignBtn.disabled = false; resignBtn.classList.add('btn-primary'); }
      startHeartbeat();
      drawBoard();
      // 无论是否有 AI 先手，处理完后轮到你
      setTurn('you');
      }catch(err){
        log('新开对局失败（网络错误）');
        showToast('新开对局失败（网络错误）');
        if(startBtn) startBtn.disabled = false;
        setPreGameControlsDisabled(false);
      } finally {
        isStartingGame = false;
      }
    }

    function startHeartbeat(){
      stopHeartbeat();
      heartbeatTimer = setInterval(async ()=>{
        if(!gameId) return;
        await fetch('/api/game/heartbeat', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ gameId }) });
      }, 15000);
    }
    function stopHeartbeat(){ if(heartbeatTimer){ clearInterval(heartbeatTimer); heartbeatTimer=null; } }

    function coordToMove(x,y){
      const gx = Math.round((x-32)/32);
      const gy = Math.round((y-32)/32);
      if(gx<0||gx>18||gy<0||gy>18) return null;
      const letters = 'ABCDEFGHJKLMNOPQRST';
      const col = letters[gx];
      const row = 19-gy;
      return col + row;
    }

    board.addEventListener('click', async (e)=>{
      if(isStartingGame){ showToast('正在开局，请稍候…'); return; }
      if(!gameId){ showToast('请先新开对局'); return; }
      if(isPlayingRequest){ return; }
      const rect = board.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const mv = coordToMove(x,y);
      if(!mv) return;

      const coord = moveToCoord(mv);
      if(!coord) return;
      if(hasStone(coord.x, coord.y)){
        log(`该点已有棋子: ${mv}`);
        return;
      }

      log(`你落子: ${mv}`);
      const applied = applyMoveLocal(playerColor, coord.x, coord.y);
      if(!applied.ok){
        log('非法落子（自杀禁手），已阻止');
        showToast('非法落子（自杀禁手）');
        return;
      }
      lastHumanMove = { x: coord.x, y: coord.y };
      if(applied.captures>0){ caps[playerColor] += applied.captures; updateCaps(); log(`提子: ${applied.captures}`); }
      drawBoard();
      // 你已落子，轮到 AI
      setTurn('ai');

      isPlayingRequest = true;
      try{
        const res = await fetch('/api/game/play', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ gameId, playerMove: mv }) });
        if(res.status === 410){
          showToast('对局已过期');
          stones = stones.filter(s => !(s.x===coord.x && s.y===coord.y && s.color===playerColor));
          drawBoard();
          // 回退你的棋，仍轮到你
          setTurn('you');
          return;
        }
        if(!res.ok){
          log('落子失败');
          showToast('落子失败');
          stones = stones.filter(s => !(s.x===coord.x && s.y===coord.y && s.color===playerColor));
          drawBoard();
          // 回退你的棋，仍轮到你
          setTurn('you');
          return;
        }
        const j = await res.json();
        const mvStr = String(j.engineMove || '').trim();
        log(`AI 应手: ${mvStr}`);
        const ai = moveToCoord(mvStr);
        const aiColor = (playerColor === 'black') ? 'white' : 'black';
        if(ai){
          const result = applyMoveLocal(aiColor, ai.x, ai.y);
          if(result.captures>0){ caps[aiColor] += result.captures; updateCaps(); log(`AI 提子: ${result.captures}`); }
          lastAiMove = { x: ai.x, y: ai.y };
          triggerAiPulse();
        }
        drawBoard();
        // AI 行棋完成，轮到你
        setTurn('you');
      }catch(err){
        log('网络错误：' + err);
        showToast('网络错误');
        stones = stones.filter(s => !(s.x===coord.x && s.y===coord.y && s.color===playerColor));
        drawBoard();
        // 回退你的棋，仍轮到你
        setTurn('you');
      }finally{
        isPlayingRequest = false;
      }
    });

    if(startBtn){
      startBtn.onclick = async () => {
        if(gameId){ return; }
        startBtn.disabled = true;
        await newGame();
      };
    }
    // restart removed
    if(debugSwitch){
      let debugMode = debugSwitch.checked;
      const applyDebugUI = () => {
        if(debugMode){
          logsPanel.style.display = 'block';
          // 无对局时不显示历史“global”日志，保持空白
          renderLogs();
        } else {
          logsPanel.style.display = 'none';
        }
      };
      applyDebugUI();
      debugSwitch.addEventListener('change', ()=>{
        debugMode = debugSwitch.checked;
        // 不再把调试模式切换写入持久化日志，避免刷新后出现大量历史切换记录
        applyDebugUI();
      });
    }
    document.getElementById('resign').onclick = async ()=>{
      if(!gameId) return;
      await fetch('/api/game/close', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ gameId }) });
      stopHeartbeat();
      log('你认输，已关闭对局');
      gameId = null;
      if(resignBtn){ resignBtn.disabled = true; resignBtn.classList.remove('btn-primary'); }
      startBtn.disabled = false;
      stones = [];
      caps = {black:0, white:0};
      updateCaps();
      drawBoard();
      // 对局结束，取消高亮
      setTurn(null);
      // 恢复赛前可配置项
      setPreGameControlsDisabled(false);
    };

    // 清空当前对局日志
    const clearBtn = document.getElementById('clearLogsBtn');
    if(clearBtn){
      clearBtn.onclick = ()=>{ const key = currentLogKey(); if(key) clearLogsForKey(key); };
    }

    // 简单 Toast 提示
    let _toastTimer = null;
    function showToast(text, durationMs = 1400){
      const el = document.getElementById('toast');
      if(!el) return;
      el.textContent = text;
      el.classList.add('show');
      if(_toastTimer) clearTimeout(_toastTimer);
      _toastTimer = setTimeout(()=>{ el.classList.remove('show'); }, durationMs);
    }

    updateCaps();
    // 初始无对局，取消高亮
    setTurn(null);
    // 初始允许修改赛前选项
    setPreGameControlsDisabled(false);

    // 页面关闭/离开时，自动关闭当前对局，避免活动局残留
    function closeGameOnUnload(){
      if(!gameId) return;
      try{
        const payload = JSON.stringify({ gameId });
        const url = '/api/game/close';
        if(navigator.sendBeacon){
          const blob = new Blob([payload], { type: 'application/json' });
          navigator.sendBeacon(url, blob);
        }else{
          // 作为降级，尽力而为；无需等待结果
          fetch(url, { method:'POST', headers:{'content-type':'application/json'}, body: payload, keepalive: true }).catch(()=>{});
        }
      }catch(_){ /* 忽略 */ }
    }
    window.addEventListener('beforeunload', closeGameOnUnload);
    window.addEventListener('pagehide', closeGameOnUnload);
  </script>
</body>
</html>
